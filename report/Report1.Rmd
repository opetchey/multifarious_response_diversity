---
title: "Response diversity in the context of multifarious environmental change."
author: "Owen Petchey, and please add"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    code_folding: hide
---

```{r include = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      include = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      cache = FALSE)
```


```{r results='hide'}
rm(list = ls())
library(plotly)
library(tidyverse)
library(here)
library(patchwork)
library(DT)
library(mgcv)
library(gratia)
source.files <- list.files(here("r"), full.names = TRUE)
sapply(source.files, source, .GlobalEnv)
```

# Introduction

Researchers have previous suggested that the response diversity of a community be measured by the diversity of responses to environmental change. For example, one can measure the response of each of the species' intrinsic growth rate to temperature, quantify the strength and direction of these responses (e.g., as the first derivative of the response curve), and calculate the diversity of responses (e.g., by calculating variation in the first derivatives among the species in a community). When responses are nonlinear, the response diversity will be a function of the environmental state (i.e. the first derivative is a function of the value of the environmental state). So far we demonstrated this approach for quantifying response diversity in the context of a single environmental factor, but given that multiple environmental factors can change simultaneously, we need an approach that works in that context.

# The principle

*Owen learned about the mathematical principles from these youtube videos:*

* [Surfaces and Partial Derivatives](https://www.youtube.com/watch?v=k4wNIZr8GU4)
* [54. Slope of the Surface in Any Direction - Directional Derivative, and Properties of the Gradient](https://www.youtube.com/watch?v=wfjipWmyRYg)


Imagine that the growth rate of a population depends on two environmental factors, e.g. temperature and salinity. We can represent the dependency as $G = f(T, S)$, where $G$ is growth rate, $T$ is temperature, and $S$ is salinity. It may be that the dependencies are linear, nonlinear, and with an interaction between temperature and salinity, hence our approach needs to be able to accommodate this phenomena.

The response of growth rate to change in temperature and salinity is the gradient / slope of this surface, with units of growth rate [per time] per temperature [degrees C] per salinity [parts per thousand]. Because the slope (first derivative) of the surface can (when dependencies are nonlinear) vary across the surface (location on the surface), and can vary in different directions on the surface, to calculate a slope we must specify the current environment (location on the surface) and the direction of change in the environment. The location on the curve is the current environmental condition, $(T_0, S_0)$, and the direction of environmental change is the unit vector $\hat{u} = \langle U_T, U_S \rangle$.

Put another way, we calculate a directional derivative at a point on the response surface. We can write this as $D_{\hat{u}}f(T_0, S_0)$ and can calculate it as $f_T(T_0, S_0)U_T + f_S(T_0, S_0)U_S$, where $f_T$ is the partial derivative of $f(T, S)$ with respect to $T$ and $f_S$ is the partial derivative of $f(T, S)$ with respect to $S$.

Efficient evaluating in $n$ dimensions can be done by taking the dot product of the partial derivatives at the location and the direction unit vector: $D_{\hat{u}}f(T_0, S_0) = \triangledown f \cdot \hat{u}$ where, $\triangledown f  = \langle f_T, f_S \rangle$. (In R, the dot product of `a` and `b` is `sum(a*b)`)

Figure  \@ref(fig:surface-sketch) is an illustration of the principle of directional derivatives on a surface.

(ref:surface-sketch) This figure needs considerable improvement! It is currently a keynote illustration.

```{r surface-sketch, echo = FALSE,  include=TRUE, fig.cap='(ref:surface-sketch)', fig.align="center", fig.height=6, fig.width=6}
knitr::include_graphics(here("report/assets/illustration_of_directional_derivatives.png"))
```


# A simulated empirical example

Numerous mathematical functions have been used to represent how organismal performance changes with an environmental driver [citation require](). Moreover, multiple mathematical functions have been used to represent an interactive effect of two or more environmental drivers on species performance [e.g. Thomas et al 2017](https://onlinelibrary.wiley.com/doi/full/10.1111/gcb.13641). *We have to decide if we are going to make simulations with different of these functions. This might increase our confidence that the method for calculating response diversity is robust to variation in types of response curve. If we decide not to, then we should likey argue that we think its robust.*

## Simulating performance curves

Let us use the Epply performance curve, which was used, for example, in this paper [Bernhardt et al. 2018](https://royalsocietypublishing.org/doi/10.1098/rspb.2018.1076).

With one environmental variable, the performance (i.e., rate) is given by:

* $rate(E) = ae^{bE}(1 - (\frac{E - z}{w/2})^2)$
* $E$ is the values of the environmental factor.
* $z$ controls location of maximum.
* $w$ controls range of $E$ over which the rate is positive.
* $a$ scaling constant.
* $b$ controls rate of increase towards the maximum rate, as $E$ increases.

Adding a second environmental variable gives:

$rate(E_1, E_2) = a_1e^{b_1E_1}(1 - (\frac{E_1 - z_1}{w_1/2})^2) + a_2e^{b_2E_2}(1 - (\frac{E_2 - z_2}{w_2/2})^2)$

In this case, it is clear the effect of $E_1$ and $E_2$ is defined as being additive. For example, the value of $E_2$ does not affect the value of $E_1$ at which the rate is maximised ($z_1$), and vice-versa (see also Figure \@ref(fig:add-epp-fig)) 

```{r}
## define the series of values of the environmental variables
E1_series <- 273.15 + seq(0, 50, 1)
E2_series <- seq(0, 50, 1)
```

```{r}
## Set parameter values
pars <- list(a1 = 1e-9,
             b1 = 0.063,
             z1 = 285,
             w1 = 60,
             a2 = 1e-3,
             b2 = 0.02,
             z2 = 20,
             w2 = 10,
             z_int21 = 0,
             wint = 0,
             sd_rate = 0)
## Make a surface / experiment
expt <- Make_expt(E1_series, E2_series, pars)
```

(ref:add-epp-fig) Nonlinear and additive dependence of a rate on two environmental variables. (a) The value of $E_1$ at which the rate is maximised is independent of the value of $E_2$. (b) The value of $E_2$ at which the rate is maximised is independent of the value of $E_1$. 

```{r add-epp-fig, fig.cap='(ref:add-epp-fig)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
pc_figs <- Plot_performance_curves(expt[[1]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```

*Including an interaction*. One way to do this is to make the value of $E_1$ at which the rate is maximised depend on the value of $E_2$:

$rate(E_1, E_2) = a_1e^{b_1E_1}(1 - (\frac{(E_1 + z_{int21}*E_2- z_1)}{w_1/2})^2 + a_2e^{b_2E_2}(1 - (\frac{E_2 - z_2}{w_2/2})^2$

When $z_{int21} = 0$ then this equation becomes the previously mentioned additive one. When $z_{int} \neq 0$ then the value of $E_1$ at which the rate is maximised is a function of the value of $E_2$. We used this method for adding an interaction due to its simplicity. Other methods could be used, and if also or otherwise used could add confidence about the robustness of the method for calculating response diversity.

```{r}
## Set parameters
pars <- list(a1 = 1e-9,
             b1 = 0.063,
             z1 = 285,
             w1 = 60,
             a2 = 1e-3,
             b2 = 0.02,
             z2 = 20,
             w2 = 10,
             bint = 0,
             z_int21 = -0.2,
             wint = 0,
             sd_rate = 0)
## Make a surface / experiment
expt <- Make_expt(E1_series, E2_series, pars)
```

(ref:int-epp-fig) Nonlinear and non-additive dependence of a rate on two environmental variables. (a) The value of $E_1$ at which the rate is maximised depends on the value of $E_2$. (b) The value of $E_2$ at which the rate is maximised is independent of the value of $E_1$. 

```{r int-epp-fig, fig.cap='(ref:add-epp-fig)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
pc_figs <- Plot_performance_curves(expt[[1]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```

## Simulating multiple species' performance curves

### No interacting environmental effects

First we create (or import) a table of parameter values of each species, with species in the rows and parameters in the columns. In the following example, only values of the $z$ parameters differ among the species (which determine the location of the maximum rate).

```{r}
set.seed(8456) ## To make the random number generation repeatable
s <- 10 # Number of species
## Set the mean parameter values
a1_mean <- 1e-9
b1_mean <- 0.063
z1_mean <- 285
w1_mean <- 60
a2_mean <- 1e-3
b2_mean <- 0.02
z2_mean <- 20
w2_mean <- 10
zint_mean <- 0
sd_rate_mean <- 0
z1_range <- 30
z2_range <- 20
## Make a table of parameter values, one row for each species,
## drawing parameter values from a normal distribution with
## specified standard deviation.
par_table <- tibble(a1 = rnorm(s, a1_mean, 0),#a1_mean/100),
                    b1 = rnorm(s, b1_mean, 0),#b1_mean/100),
                    z1 = runif(s, min = z1_mean - z1_range/2, max = z1_mean + z1_range / 2),
                    w1 = rnorm(s, w1_mean, 0),#w1_mean/100),
                    a2 = rnorm(s, a2_mean, 0),#a2_mean/100),
                    b2 = rnorm(s, b2_mean, 0),#b2_mean/100),
                    z2 = runif(s, min = z2_mean - z2_range/2, max = z2_mean + z2_range / 2),
                    w2 = rnorm(s, w2_mean, 0),#w2_mean/100),
                    z_int21 = rnorm(s, zint_mean, zint_mean/10),
                    sd_rate = rnorm(s, sd_rate_mean, sd_rate_mean/10)
                    )
```

```{r results='asis', message=FALSE, warning=FALSE}
## Display the parameter table
DT::datatable(par_table,
              filter="top")
```

For convenience we then convert the table of parameters into a [list-column](https://dcl-prog.stanford.edu/list-columns.html). We can then easily make performance curves of each of the species, and put those into a list-column in the same table.

```{r echo = TRUE}
## convert parameter table to a list-column of a tibble
par_list <- Partable_2_parlist(par_table)
## add performance curves
species_pars <- tibble(species = paste0("s", 1:s), pars = par_list) %>%
  rowwise() %>%
  mutate(expt = Make_expt(E1_series, E2_series, pars))
```

Here are some examples of the species' performance curves (only with additive effects of $E_1$ and $E_2$).

(ref:lowE1-opt-species) Performance curves for a species with maximum growth at **low** values of $E_1$.  Without interacting environmental effects.

```{r lowE1-opt-species, fig.cap='(ref:lowE1-opt-species)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
this_one <- which(par_table$z1 == min(par_table$z1))
pc_figs <- Plot_performance_curves(species_pars$expt[[this_one]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')

```

(ref:highE1-opt-species) Performance curves for a species with maximum growth at **high** values of $E_1$. Without interacting environmental effects.

```{r highE1-opt-species, fig.cap='(ref:highE1-opt-species)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
this_one <- which(par_table$z1 == max(par_table$z1))
pc_figs <- Plot_performance_curves(species_pars$expt[[this_one]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```

(ref:lowE2-opt-species) Performance curves for a species with maximum growth at **low** values of $E_2$. Without interacting environmental effects.

```{r lowE2-opt-species, fig.cap='(ref:lowE2-opt-species)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
this_one <- which(par_table$z2 == min(par_table$z2))
pc_figs <- Plot_performance_curves(species_pars$expt[[this_one]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')

```

(ref:highE2-opt-species) Performance curves for a species with maximum growth at **high** values of $E_2$. Without interacting environmental effects.

```{r highE2-opt-species, fig.cap='(ref:highE2-opt-species)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
this_one <- which(par_table$z2 == max(par_table$z2))
pc_figs <- Plot_performance_curves(species_pars$expt[[this_one]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```


### Interacting environmental effects

And now with interacting environmental effects...

```{r}
set.seed(18456)
s <- 10 # Number of species
a1_mean <- 1e-9
b1_mean <- 0.063
z1_mean <- 285
w1_mean <- 60
a2_mean <- 1e-3
b2_mean <- 0.02
z2_mean <- 20
w2_mean <- 10
zint_mean <- -0.2
sd_rate_mean <- 0
z1_range <- 30
z2_range <- 20

par_table <- tibble(a1 = rnorm(s, a1_mean, 0),#a1_mean/100),
                    b1 = rnorm(s, b1_mean, 0),#b1_mean/100),
                    z1 = runif(s, min = z1_mean - z1_range/2, max = z1_mean + z1_range / 2),
                    w1 = rnorm(s, w1_mean, 0),#w1_mean/100),
                    a2 = rnorm(s, a2_mean, 0),#a2_mean/100),
                    b2 = rnorm(s, b2_mean, 0),#b2_mean/100),
                    z2 = runif(s, min = z2_mean - z2_range/2, max = z2_mean + z2_range / 2),
                    w2 = rnorm(s, w2_mean, 0),#w2_mean/100),
                    z_int21 = rnorm(s, zint_mean, abs(zint_mean/10)),
                    sd_rate = rnorm(s, sd_rate_mean, sd_rate_mean/10)
                    )
```

```{r results='asis', message=FALSE, warning=FALSE}
DT::datatable(par_table,
              filter="top")
```

For convenience we then convert the table of parameters into a [list-column](https://dcl-prog.stanford.edu/list-columns.html). We can then easily make performance curves of each of the species, and put those into a list-column in the same table.

```{r echo = TRUE}
## convert parameter table to a list-column of a tibble
par_list <- Partable_2_parlist(par_table)
## add performance curves
species_pars <- tibble(species = paste0("s", 1:s), pars = par_list) %>%
  rowwise() %>%
  mutate(expt = Make_expt(E1_series, E2_series, pars))
```

Here are some examples of the species' performance curves (with interacting effects of $E_1$ and $E_2$).

(ref:lowE1-opt-species1) Performance curves for a species with maximum growth at **low** values of $E_1$. With interacting environmental effects.

```{r lowE1-opt-species1, fig.cap='(ref:lowE1-opt-species1)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
this_one <- which(par_table$z1 == min(par_table$z1))
pc_figs <- Plot_performance_curves(species_pars$expt[[this_one]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')

```

(ref:highE1-opt-species2) Performance curves for a species with maximum growth at **high** values of $E_1$.  With interacting environmental effects.

```{r highE1-opt-species2, fig.cap='(ref:highE1-opt-species2)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
this_one <- which(par_table$z1 == max(par_table$z1))
pc_figs <- Plot_performance_curves(species_pars$expt[[this_one]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```

(ref:lowE2-opt-species2) Performance curves for a species with maximum growth at **low** values of $E_2$. With interacting environmental effects.

```{r lowE2-opt-species2, fig.cap='(ref:lowE2-opt-species2)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
this_one <- which(par_table$z2 == min(par_table$z2))
pc_figs <- Plot_performance_curves(species_pars$expt[[this_one]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')

```

(ref:highE2-opt-species2) Performance curves for a species with maximum growth at **high** values of $E_2$. With interacting environmental effects.

```{r highE2-opt-species2, fig.cap='(ref:highE2-opt-species2)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
this_one <- which(par_table$z2 == max(par_table$z2))
pc_figs <- Plot_performance_curves(species_pars$expt[[this_one]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```


## Fitting GAMs to noisy rate observations

Try with and without an interaction. Therefore make two species, one with no interaction `z_int = 0` and the other with `z_int = 0.1`. All other parameters are the same. Note that noise is added to the rate observations.

GAM notes:

* Owen watched this youtube video [Introduction to Generalized Additive Models with R and mgcv](https://youtu.be/sgw4cu8hrZM) by Gavin Simpson (author of the `gratia` package that we've been using to calculate derivatives of GAMs.). By the way, there is a part of this video about Model Selection, about Confidence Intervals, and about p-values for smooths (about 1h:57m to 2h:26) which I think is less useful for our purposes.
* In the video mentioned above [at about 54m:30s](https://youtu.be/sgw4cu8hrZM?t=2730), there is the recommendation to estimate the penalisation parameter ($\lambda$) via restricted maximum likelihood, which is done by giving the the argument `method = "REML` in the `gam()` call (the default in `mgcv` version 1.8-36 is `method="GCV.Cp"`).
* Default smoother is a *low rank thin plate spline* (`bs = "tp"`)
* `s(E1, E2) will fit a *bivariate isotropic thin plate spline*. *Isoptropic* means there is a single smoothness parameter for the smooth. It is sensitive to the scale of $E1$ and $E2$.
* Tensor products (`te(E1, E2`) have separate marginal basis, and therefore separate smoothness parameters. They are invariant to scales of $E1$ and $E2$. Therefore we should be using tensor products.
* Specifying a model with `te(E1, E2`) does not then allow inspection of the main effects and interaction term--there is essentially only one smoother which contains the main effects and interaction. So it is difficult to know if the interaction term is required. An alternative is to specify the model as `s(E1) + s(E2) + ti(E1, E2)`, in which the third term is then only the interaction part and allows a decomposition into the different effects. Useful for examining if the interaction is required.
* To use cubic splines use `bs = "cr"`.
* There are many smoothers in `mgcv`
* Choosing *k* (the *basis complexity*, which is the maximum wiggliness) is a bit of an art. The penalty then shrinks the used basis complexity, reducing the effective degrees of freedom. Must check that large enough *k* is provided; use `gam.check()`. Only cost to large $k$ is computational effort.

Bottom line is that the gam picks up an interaction when we have included in the parameters used to generation the rates, and does not pick one up when we have not made an interaction. This confirms that our more mechanistic thinking and methods are matching our statistical thinking and methods, and confirms that each are promising, so far.

```{r}
set.seed(2456)
s <- 2 ## number of species
a1_mean <- 1e-9
b1_mean <- 0.063
z1_mean <- 285
w1_mean <- 60
a2_mean <- 1e-3
b2_mean <- 0.02
z2_mean <- 20
w2_mean <- 10
zint_mean <- 0 ## set in the preceding chunk
sd_rate_mean <- 0.02
z1_range <- 0
z2_range <- 0
par_table <- tibble(a1 = rnorm(s, a1_mean, 0),#a1_mean/100),
                    b1 = rnorm(s, b1_mean, 0),#b1_mean/100),
                    z1 = runif(s, min = z1_mean - z1_range/2, max = z1_mean + z1_range / 2),
                    w1 = rnorm(s, w1_mean, 0),#w1_mean/100),
                    a2 = rnorm(s, a2_mean, 0),#a2_mean/100),
                    b2 = rnorm(s, b2_mean, 0),#b2_mean/100),
                    z2 = runif(s, min = z2_mean - z2_range/2, max = z2_mean + z2_range / 2),
                    w2 = rnorm(s, w2_mean, 0),#w2_mean/100),
                    z_int21 = rnorm(s, zint_mean, zint_mean/10),
                    sd_rate = rnorm(s, sd_rate_mean, 0)
                    )
## set z_int of the second species to non-zero value
par_table$z_int21[2] <- -0.2

## The normal house keeping
par_list <- Partable_2_parlist(par_table)
species_pars <- tibble(species = paste0("s", 1:s), pars = par_list) %>%
  rowwise() %>%
  mutate(expt = Make_expt(E1_series, E2_series, pars))
```

```{r results='asis', message=FALSE, warning=FALSE}
DT::datatable(par_table,
              filter="top")
```

### Without interaction

```{r}
which_species <- 1 ## 1 is without interaction, 2 is with
```

(ref:gamtest-species1) Performance curves for a species *without* interacting environmental effects and with some noise in the rate.

```{r gamtest-species1, fig.cap='(ref:gamtest-species1)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
pc_figs <- Plot_performance_obs(species_pars$expt[[which_species]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```



```{r eval = TRUE}
## gam with interaction
gam1 <- gam(rate ~ ti(E1) + ti(E2) + ti(E1, E2),
            data = species_pars$expt[[which_species]],
            method = "REML")
summary(gam1)
new_data <- expand_grid(E1 = E1_series,
                        E2 = E2_series)
fit1 <- predict(gam1, new_data)
pred1 <- bind_cols(new_data, rate = fit1)
gam1_plots <- Plot_performance_curves(pred1)
gam1_plots[[1]] + gam1_plots[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```

```{r eval = TRUE}
## gam without interaction
gam2 <- gam(rate ~ s(E1) + s(E2),
            data = species_pars$expt[[which_species]],
            method = "REML")
summary(gam2)
fit2 <- predict(gam2, new_data)
pred2 <- bind_cols(new_data, rate = fit2)
gam2_plots <- Plot_performance_curves(pred2)
gam2_plots[[1]] + gam2_plots[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```




### With interaction

```{r}
which_species <- 2 ## 1 is without interaction, 2 is with
```

(ref:gamtest-species2) Performance curves for a species *with* interacting environmental effects and with some noise in the rate.

```{r gamtest-species2, fig.cap='(ref:gamtest-species2)', fig.align="center", fig.height=3, fig.width=8}
## Visualise the performance surface of a species
pc_figs <- Plot_performance_obs(species_pars$expt[[which_species]])
pc_figs[[1]] + pc_figs[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```



```{r eval = TRUE}
## gam with interaction
gam3 <- gam(rate ~ ti(E1) + ti(E2) + ti(E1, E2),
            data = species_pars$expt[[which_species]],
            method = "REML")
summary(gam3)
fit3 <- predict(gam3, new_data)
pred3 <- bind_cols(new_data, rate = fit3)
gam3_plots <- Plot_performance_curves(pred3)
gam3_plots[[1]] + gam3_plots[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```

```{r eval = TRUE}
## gam without interaction
gam4 <- gam(rate ~ s(E1) + s(E2),
            data = species_pars$expt[[which_species]])
summary(gam4)
fit4 <- predict(gam4, new_data)
pred4 <- bind_cols(new_data, rate = fit4)
gam4_plots <- Plot_performance_curves(pred4)
gam4_plots[[1]] + gam4_plots[[2]] + plot_annotation(tag_levels = 'a',
                              tag_prefix = '(',
                              tag_suffix = ')')
```


## Getting the directional derivative

First step is estimate the two partial derivatives $f_{E1}(E1_0, E2_0)$ and $f_{E2}(E1_0, E2_0)$ (please review the section [The principle] if necessary). This is not currently working. Please look at and perhaps run the R code for more details.

```{r eval = FALSE}
## Specify the values of E1 and E2 at which to evaluation the partial derivatives
E1E2_locs <- tibble(E1 = 300,
                    E2 = 20)
## not necessary, but try predicting the rate at that location
pred_rate <- predict.gam(gam1, newdata = E1E2_locs) # works
## now try getting the partial derivative
try(derivs1 <- derivatives(gam1, data = E1E2_locs)) ## does not work for gam1, which includes the term ti(E1, E2)
derivs1 <- derivatives(gam2, data = E1E2_locs) ## does work for gam2, which has no interaction term, though had to chance the main effects to s()
```





## To do

* The mathematical formulation of the interaction term is not very good. Too much changes when the $z_int$ term is changed.
* Collect data on response of growth rate to temperature and salinity for a collection of species. [We will simulate this, including response surfaces with combinations of linear and nonlinear responses, and without and with interactions among temperature and salinity.]
* Fit a response surface to that data. [Do with GAMs with interactions.]
* Specify the species present in a community and the temperature and salinity environment it occurs in. [We will simulate this, with different directions of change in temperature and salinity, e.g. independent, positively correlated, negatively correlated.]
* Show examples of response diversity for the simulated environmental change scenarios and community compositions. [ Make function to calculate directional derivative at location, and calculate diversity of this across the species present in a specific community.]

# Issues

* The scales of the environmental change factors are different, and so some standardisation will be needed.

# Left-overs

Also imagine that we are studying an ecosystem that can experience simultaneous change in temperature and salinity. For example, at a particular time, the temperature might be increasing by 0.1 C per day and salinity increasing by 0.2 parts per thousand per day.

*Here some text that Sam wrote for a previous ms, that we removed from there, though please confirm this before using it in here* The framework proposed herein allows derivation of environment-dependent performance responses. Yet, when species are exposed to multiple environmental stressors simultaneously—a situation common in empirical systems (Bowler et al. 2020)—it is not trivial to derive performance responses. Conceptually, the principles of measuring response diversity should still apply in multiple dimensions, but the analytical formulation must necessarily differ. If multiple environmental stressors act additively, then it should be mathematically straightforward to produce a multivariate response surface with performance varying as a function of two (or more) environmental conditions. However, where multiple stressors interact, nonadditivity adds additional layers of complication to the formulation of multivariate response surfaces (e.g., Yang et al. 2022). In such cases, a different analytical approach to estimating multivariate response diversity is needed. Future work should extend the univariate response diversity principles we suggest here into a multivariate framework for measuring response diversity to multiple environmental stressors. In doing so, multivariate response diversity may link conceptually to the study of co-tolerance to multiple stressors and stress-induced community sensitivity (see Vinebrooke et al. 2004) and should prove more operationalizable than univariate approaches given the propensity for multiple environmental stressors to not only co-occur but to interact nonadditively in nature (Dieleman et al. 2012).


```{r eval = FALSE}
## code to plot a surface
expt_wide <- pivot_wider(expt, values_from = rate, names_from = E2)
plot_matrix <- as.matrix(expt_wide[,-1])
axis1 <- as.vector(expt_wide[,1])
axis2 <- names(expt_wide)[-1]
fig <- plot_ly(x = axis1, y = axis2, z = t(plot_matrix)) %>%
   add_surface() %>%
   layout(scene = list(xaxis = list(title = 'Temperature'),
                       yaxis = list(title = 'Salinity'),
                       zaxis = list(title = "Growth rate")))
fig
# htmlwidgets::saveWidget(fig, "3dsurface_widget.html")      
```



```{r eval = FALSE}
# #The commented code below was used to make the original surface illustration
# pars <- list(c = 2000,
#           t_1 = 0.1,
#           t_2 = -2,
#           s_1 = 0,
#           s_2 = 0,
#           ts_1 = 2)
# scaler <- 1/1000
# growth_rate_T_S <- function(T, S) {
#   pars$c +
#     pars$t_1 * T +
#     pars$t_2 * T^2 +
#     pars$s_1 * S +
#     pars$s_2 * S^2 +
#     pars$ts_1 * T * S
# }
# T_axis <- seq(5, 30, 1)
# S_axis <- seq(1, 80, 1)
# growth_rate_matrix = outer(X = T_axis,
#                            Y = S_axis,
#                            FUN = growth_rate_T_S) * scaler
# fig <- plot_ly(x = S_axis, y = T_axis, z = t(growth_rate_matrix)) %>%
#   add_surface() %>%
#   layout(scene = list(xaxis = list(title = 'Temperature'),
#                       yaxis = list(title = 'Salinity'),
#                       zaxis = list(title = "Growth rate")))
# htmlwidgets::saveWidget(fig, "3dsurface_widget.html")                       
```


